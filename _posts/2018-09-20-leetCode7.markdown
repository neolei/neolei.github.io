---
layout:     post
title:      “LeetCode:7”
subtitle:   “reverse-integer”
date:       2018-09-20
author:     “Soptq”
header-img: "img/post_leetcode.jpg"
catalog:    false
tags:
    - LeetCode Easy
    - Java
---


>长期更新，对使用 Java 刷 LeetCode 过程中一些有趣的题的感想和启发。
>[解题源代码仓库](https://github.com/Soptq/LeetCodeLib)

### 题目

> [题目链接](https://leetcode-cn.com/problems/reverse-integer/description/)
> 
> Given a 32-bit signed integer, reverse digits of an integer.
> 
> Example 1:
> 
> Input: 123
> Output: 321
> Example 2:
> 
> Input: -123
> Output: -321
> Example 3:
> 
> Input: 120
> Output: 21
> Note:
> Assume we are dealing with an environment which could only store 
> integers within the 32-bit signed integer range: [−231,  231 − 1]. 
> For the purpose of this problem, assume that your function 
> returns 0 when the reversed integer overflows. 

### 我的思路

这道题的真正难点应该是判断是否溢出，对于每一次截取的个位反转过程中都需要乘以10来成为十位，所以我们只需要判断每一次截取的个位（`rev`）乘以10后是否超出范围就可以了。

所以，

1. 当 `rev` 比溢出最大值的十分之一还要大时，必然溢出。
2. 当 `rev` 等于溢出最大值的十分之一时，且各位大于7时，也必然溢出。
3. 负数同理。

### 我的代码

```java
//解决方法
class Solution {
	public int reverse(int x) {
		int rev = 0;
		int last;
		while (x != 0){
			last = x % 10;
			x /= 10;
			if (rev > Integer.MAX_VALUE/10 || rev == Integer.MAX_VALUE/10 && last > 7) {
				return 0;
			}
			if (rev < Integer.MIN_VALUE/10 || rev == Integer.MIN_VALUE/10 && last < -8) {
				return 0;
			}
			rev = rev * 10 + last;
		}
		return rev;
	}
}
```








